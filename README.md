# Design and Interfacing of Serial Peripheral Interface (SPI) with SRAM Array in 0.6um CMOS

## Abstract
This project report provides details on the semi-custom design of SPI Interface with SRAM Array for IOT based embedded system implemented in a 0.6μm CMOS technology. The SPI Interface which aids in the write and read operations from a (16 x 16) bit SRAM was designed, simulated, layout done and tested successfully using Cadence and Spectre. The innovation of this project lies in creating and controlling all the signals required for the SRAM without use of internal clocks, deriving all control signals from the SPI signals themselves instead, thereby making it a simple and scalable circuit that can be made to consume very little power with slower access time.

## Introduction
Serial Peripheral Interface or SPI is a synchronous serial communication protocol that provides full – duplex communication at very high speeds. It is a master – slave type protocol that provides a simple and low-cost interface between a microcontroller and its peripherals. It has a single master and can have one or multiple slaves.   

A common serial port is called ‘asynchronous’ because the data sent and received are not synced with each other hence leading to some discrepancies. Therefore, asynchronous serial connections add extra start and stop bits to each byte as well as the transmission speed is set to help the receiver sync up to data as it arrives. These extra bits require lot of overhead and also contribute to complex hardware. On the other hand, SPI is a ‘synchronous’ data bus which uses separate lines for data and a clock that helps for perfect sync between both sides.  

SPI is called a four-wire serial bus consisting of four signals/pins: -
 - MOSI(Master Out Slave In) - Data flows from master to slave through it.
 - MISO(Master In Slave Out) - Data flows from slave to master through it.
 - SCLK(Synchronous Clock) - Generated from the master to make clock synchronous with data signals of the slave.
 - CS/SS(Chip Select/Slave Select) – Signal to select a particular slave used by master for communication.  
 
The master controls the clock frequency, polarity and phase w.r.t. data. The CPOL bit sets the polarity of the clock signal during the idle state. The CPHA bit selects the clock phase. Depending on the CPHA bit, the rising or falling clock edge is used to sample and/or shift the data. A master-slave pair must use the same set of parameters: SCLK frequency, CPOL, and CPHA for an effective communication. Depending on the CPOL and CPHA bit selection, four SPI modes are available as shown in Table I. Out of the four modes, mode 3 is implemented in this project. 

|  SPI Modes |	CPOL | CPHA | Idle Clock  |	Data Rx/Tx from Master        |
|:------------------:|:---------------:|:---------------:|:---------------:|:---------------:|
| 0  | 0  | 0  | Low | Rising Edge Sample, Falling Edge Data | 
| 1  | 0  | 1  | Low | Falling Edge Sample, Rising Edge Data |
| 2  | 1  | 1  | High | Falling Edge Sample, Rising Edge Data |
| 3  | 1  | 0  | High | Rising Edge Sample, Falling Edge Data |

Table 1: SPI Modes

## Circuit Design

SPI schematic consists of 16- bit shift registers as shown in figure 1. These shift registers are basically D-FF (D-Flip Flops) connected one after another providing the function of shift registers as a whole. The components that have been used here are given below along with their purposes-

|<img title="SPI Shift Registers" src="images/shift_registers_SPI.jpg">|  
|:--:| 
|*Figure 1: SPI Architecture*|

### Components

1) CSN (Chip Select Line) - It is an active low signal represented as CS bar generated by the master block of SPI signal. Whenever it is low, only then the slave of SPI functions. 
2) MOSI (Master Out Slave In) - Serially, data is transferred from the master to the slave. This acts as the input to the 1st D FF and hence each bit is shifted by the shift register in each clock cycle.
3) MISO (Master In Slave Out) - The data is serially transferred from the slave to the master. This acts as the output from the last D-FF. Each bit is shifted and is obtained as output one by one.
4) SCLK (Synchronous Clock) - This signal is also generated by the master and sent to the slave. Depending on the positive and negative edge triggered flip-flop, the data is shifted accordingly. The signals also are activated or deactivated depending on each clock pulse.
5) MUXEN (MUX Enable) - This signal is used for enabling the MUX 2:1. When it is 0, input I0 of the MUX is selected. On the other hand, when it is 1, input I1 of the MUX is selected. It is used in the read operation.
6) RST (Reset) - This is a signal used to set the Flip-Flops to their predetermined state, either by the device itself or externally whenever required. The reset used here is an active high reset signal.
7) GATES- Here, two types of gates, each two in number are used. Inverters are used to make the chip select line active low. AND gates are used too.
8) DFFs- Two types of D-FFs are used.
    - a) DFRRQX1- D-FF with reset signal and positive edge triggered. 8 of these are used.
    - b) DFFQX1- D-FF with negative edge triggered and no reset. 8 of these are used.
9) 2:1 MUX- Seven MUXes are used mainly for read operation. It transfers either of the two inputs I0 and I1 depending on the MUXEN signal and provides the output which is input to the flip-flops.
10) D<7:0> - These are 8-bit data lines (D0, D1, D2, D3, D4, D5, D6, D7) that are parallel inputs to the flip-flops through MUX. They come from the SRAM cell during READ operation.
11) QA<7:0> - These are 8-bit output lines (QA0, QA1, QA2, QA3, QA4, QA5, QA6, QA7) from DFRRQX1. These are used in WRITE operation for writing 8-bit into the SRAM cell.




